# Архитектура KataCut (высокоуровнево, без примеров кода)

Область: контекст системы, контейнеры, роли компонентов, потоки `sync` (dry‑run/apply), модель плана/таргетов, адаптеры, ошибки/восстановление, телеметрия, тестирование, безопасность, дорожная карта. Визуализация — ASCII/ANSI‑схемы.

## 1) Цель и не‑цели
- Цель: дать стабильную ментальную модель развития `@katacut/cli` без привязки к деталям реализации.
- Не‑цели: без примеров кода, без фиксации публичных API, без гайдов под конкретных вендоров.

## 2) Принципы
- Hexagonal (Порты/Адаптеры): домен отделён от I/O.
- Детерминированный и идемпотентный `sync`; по умолчанию — dry‑run.
- Схема как источник истины; строгая валидация; не используем `null` (только `undefined`).
- Минимально необходимые привилегии; явные побочные эффекты; наблюдаемость «из коробки».

## 3) Системный контекст

```
  +--------+        +-----------+        +---------+
  | Польз. | -----> |    CLI    | -----> |  Core   |
  +--------+        +-----------+        +---------+
                         |   |
                         |   v
                         | +-----------+
                         | |  Schema   |
                         | +-----------+
                         v
                    +-----------------+
                    |    Adapters     |
                    +-----------------+
                         |       \
                         v        v
                    +--------+  +-------------+
                    |  FS    |  |   Clients   |
                    +--------+  +-------------+
                                     |
                                     v
                            +------------------+
                            |   OS / Tools     |
                            +------------------+

  Внешнее:
    CLI - - - > MCP Registry
    CLI - - - > Secrets Provider
```

Пояснения: CLI оркеструет; Schema валидирует; Core строит план; Adapters применяют к клиентам (файлы/CLI); внешние реестры/секреты подключаются явно.

## 4) Контейнеры (монорепо)

```
packages/
  schema   (@katacut/schema)  [JSON Schema + AJV]
  core     (@katacut/core)    [Plan & Diff]
  cli      (@katacut/cli)     [Команды]
  utils    (@katacut/utils)   [FS/Ошибки/Логи]
  adapters (@katacut/adapters/*)
    ├─ client-cursor
    ├─ client-vscode
    ├─ client-visual-studio
    └─ client-claude

Связи:
  CLI  -> SCHEMA, CORE, UTILS
  CORE -> ADAPTERS
  ADAPTERS -> UTILS
```

## 5) Ответственности компонентов
- Schema: парсит/валидирует JSONC; возвращает типизированный конфиг или структурированные ошибки.
- Core: чистые функции — строит `SyncPlan` (summary, targets, diff), без I/O.
- Adapters: применяют таргеты к конкретным клиентам (файлы/CLI), транзакционные записи.
- CLI: оркестровка сценариев, флаги (`--dry-run`, `--apply`, `--config`), стабильный вывод.
- Utils: утилиты FS/ошибок/логирования без состояния.

## 6) Поток sync (dry‑run)

```
1) Пользователь: katacut sync --dry-run
2) CLI: читает и валидирует конфиг через Schema
3) Core: строит план (summary, targets, diff)
4) CLI: печатает план (JSON + человеко‑читаемое summary)
```

## 7) Поток sync (apply)

```
1) Пользователь: katacut sync --apply
2) CLI: валидирует конфиг (Schema)
3) Core: строит план и диффы
4) По каждому таргету:
   4.1) CLI вызывает адаптер
   4.2) Адаптер пишет во временный файл → атомарно переименовывает
   4.3) Адаптер возвращает результат: created/updated/skip
5) CLI: итоговый отчёт по таргетам
```

## 8) Модель плана и таргетов (концепция)

```
+-------------------+
|     SyncPlan      |
|-------------------|
| summary: string   |
| targets: Target[] |
+-------------------+
          |
          v
+-------------------------------+
|          Target               |
|-------------------------------|
| name: string                  |
| client: cursor|vscode|claude|vs|
| destination: path|command     |
| contentHash: string           |
| diff: { kind, preview }       |
| actions: [create|update|skip] |
+-------------------------------+
```

## 9) Порты и адаптеры

```
Core --(targets)--> ApplyPort --> [Adapter: Cursor] --> .cursor/mcp.json
                                 \-> [Adapter: VS Code] -> .vscode/mcp.json
```

Обязанности адаптера: выбор области (project/user), стабильный JSON (порядок ключей, перевод строки в конце), транзакционные записи (temp + rename), точный отчёт.

## 10) Ошибки и восстановление
- Классы: ValidationError, AdapterError, IO‑отчёт, UnexpectedError.
- Политика:
  - Валидационные ошибки → немедленный отказ (non‑zero), печать всех issues.
  - Ошибки применения → агрегируем по таргетам; общий статус «ошибка», если критический таргет не применён.
  - Всегда поддерживаем `--dry-run` для предварительного осмотра.
- Идемпотентность: совпадающее содержимое → `skip` (diff.kind = none).

## 11) Телеметрия и наблюдаемость (концепция)
- Трассы: `sync.parse`, `sync.validate`, `sync.plan`, `sync.diff`, `adapter.apply`.
- Метрики: длительность операций, число записей, created/updated/skipped.
- Логи: структурированные строки по таргету (client, action, result).

## 12) Тестирование
- Unit (Schema/Core): чистые функции; «золотые» фикстуры планов/диффов.
- Contract (Adapters): снапшоты ожидаемых файлов/команд из таргетов.
- CLI: снапшоты stdout для `--dry-run`/`--apply` (моки адаптеров).
- E2E (smoke): чистый проект → `init → sync --dry-run → sync --apply`.

## 13) Безопасность и приватность
- По умолчанию секреты не сохраняем; подключаем только по явной настройке.
- Пишем только известные пути; глобальные записи — по явному выбору пользователя.
- Без сетевых вызовов без флага/указания; временные файлы — в безопасных директориях.

## 14) Дорожная карта (фазы)
1. Ужесточить схему MCP (http|stdio; обязательные поля).
2. Core: реальные таргеты (сначала Cursor) + краткий diff.
3. Adapter Cursor: детерминированная запись JSON, идемпотентность.
4. CLI `sync --apply`: связать с адаптерами; стабильный вывод/коды выхода.
5. Adapter VS Code (project scope): расширить покрытие клиентов.
6. Doctor (детект клиентов/путей) + базовые хуки телеметрии.

## 15) Глоссарий
- Таргет: конкретная инструкция материализовать конфигурацию для клиента.
- Дифф: краткое описание отличий между желаемым и текущим состоянием.
- Apply: выполнение побочных эффектов для достижения желаемого состояния.

## 16) Scopes, Global и политика установки (планы)

Цель: явно различать «задекларированное» проектом и «фактическое» состояние у пользователя, уметь работать с клиентами, которые не поддерживают проектный scope, и дать удобную глобальную установку по аналогии с npm/pnpm (`-g`, `--global`).

Ключевые понятия
- Scope: `project` | `user` | `global`.
  - `project` — локально в репозитории (например, `./.mcp.json`).
  - `user` — пользовательский профиль клиента (домашний каталог).
  - `global` — явная глобальная установка по аналогии с npm `-g` (вне управления проектом/lockfile).
- Декларация vs Факт:
  - Декларация (Desired): то, что описано в `katacut.config.*` и зафиксировано в lockfile.
  - Факт (Realized): то, что реально установлено у пользователя в `project/user/global`.
- Режим применения (Mode): `native` | `emulated` | `global`.
  - `native` — установлен ровно в запрошенный scope, как поддерживается клиентом.
  - `emulated` — «псевдо‑project» через `user`, если клиент не умеет `project` (с прозрачной пометкой).
  - `global` — явная установка «навсегда», не управляется проектом.

Политика по умолчанию
- Предпочтение `project` (если клиент поддерживает natively).
- Если `project` недоступен, допускаем эмуляцию через `user` (Mode = `emulated`).
- Если нет ни `project`, ни эмуляции — операция невозможна (ошибка с подсказкой).
- Явный `--global`/`-g` всегда выполняет «вне проекта» и не попадает в lockfile.

Интерфейс возможностей адаптера (capabilities)
```
capabilities(): {
  supportedScopes: Set<'project'|'user'>,
  emulateProjectWithUser: boolean,
  supportsGlobalExplicit: boolean
}
```

Контракты apply (расширение)
```
applyInstall(steps, requestedScope, policy) -> Array<{
  name: string,
  requestedScope: 'project'|'user',
  realizedScope: 'project'|'user'|'global',
  mode: 'native'|'emulated'|'global',
  outcome: 'added'|'updated'|'remove'|'skip'|'failed',
  reason?: string
}>
```

Lockfile и локальный state
- Lockfile `katacut.lock.json` (в репозитории): фиксирует желаемое состояние проекта.
  - Структура (концепция):
  ```json
  {
    "version": "0",
    "client": "claude-code",
    "mcpServers": {
      "<name>": { "scope": "project|user", "fingerprint": "sha256(stable-json)" }
    }
  }
  ```
- Локальный state `.katacut/state.json` (в `.gitignore`): фиксирует фактический результат применения на машине.
  - Пишется `kc install` после успеха.
  - Содержит: hostname/machineId, timestamp, версию CLI/adapter, per‑server: `requestedScope`, `realizedScope`, `mode`, `appliedFingerprint`, `sourcePath?`, `result`.

CLI‑поведение и UX
- Установка по умолчанию: `kc install` предпочитает `project`, при необходимости эмулирует через `user` (если политика разрешает).
- Глобальная установка: `kc install -g <name>` или отдельные команды `kc global add/remove/list`.
  - `global` никогда не попадает в lockfile, но фиксируется в пользовательском глобальном состоянии (для `doctor` и `remove -g`).
- Удаление:
  - Проектное: через план/`--prune` влияет только на управляемые проектом записи.
  - Глобальное: `kc global remove <name>` или `kc install -g --remove <name>` — по аналогии с npm.

Doctor и верификация
- `kc doctor` сопоставляет три источника: Desired (lockfile) ↔ Realized (файлы/клиент) ↔ Local state.
- Отчёт подсвечивает: drift (несовпадение fingerprint), emulated установки, unsupported, проблемы прав.
- Коды выхода: `0=ok`, `1=warn` (дрейф/эмуляции), `2=error` (нет CLI/прав/невозможно выполнить политику).

ASCII‑схема принятия решения (упрощённо)
```
Requested: project
      |
      v
Client supports project? -- yes --> native(project)
      | no
      v
Emulation allowed? ------ yes --> emulated(user)
      | no
      v
error (unsupported)
```

Что не попадает в lockfile
- Любые явные глобальные операции (`-g`, `--global`).
- Пользовательские записи, не управляемые проектом.

Открытые вопросы (в работе)
- Профили (переключатели политики и scope на уровень пользователя/окружения) — спроектировать после стабилизации lockfile/state.
